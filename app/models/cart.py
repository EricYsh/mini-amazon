from flask import current_app as app


# For reference, the SQL for the Users table is as follows:
# 
# CREATE TABLE Carts (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     userid INT NOT NULL REFERENCES Users(id),
#     quantity INT NOT NULL,
#     sellerinventoryid INT NOT NULL REFERENCES SellerInventories(id)
#     saved_for_later BOOLEAN DEFAULT FALSE
# );

# CREATE TABLE PriceHistory (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     inventoryid INT NOT NULL REFERENCES SellerInventories(id),
#     price DECIMAL(12,2) NOT NULL,
#     time_changed timestamp without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC')
# );

# CREATE TABLE Products (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     categoryid INT NOT NULL REFERENCES Categories(id),
#     name VARCHAR(255) UNIQUE NOT NULL,
#     description VARCHAR(511),
#     image VARCHAR(255)
# );

# CREATE TABLE SellerInventories (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     sellerid INT NOT NULL REFERENCES Users(id),
#     productid INT NOT NULL REFERENCES Products(id),
#     quantity INT NOT NULL CHECK (quantity >= 0)
# );

class Cart:
    def __init__(self, id, userid, quantity, sellerinventoryid, saved_for_later):
        self.id = id
        self.userid = userid
        self.quantity = quantity
        self.sellerinventoryid = sellerinventoryid
        self.saved_for_later = saved_for_later


    @staticmethod
    def get_all_by_uid(uid, saved_for_later=False):
        rows = app.db.execute('''
SELECT p.name, p.image, ph.price, c.quantity, p.id, c.id, si.id, si.sellerid
FROM Carts c
JOIN SellerInventories si ON c.sellerinventoryid = si.id
JOIN Products p ON si.productid = p.id
JOIN PriceHistory ph ON ph.inventoryid = si.id
JOIN (
    SELECT inventoryid, MAX(time_changed) AS max_time
    FROM PriceHistory
    GROUP BY inventoryid
) ph2 ON ph.inventoryid = ph2.inventoryid AND ph.time_changed = ph2.max_time
WHERE c.userid = :uid AND c.saved_for_later = :saved_for_later;
''',
                              uid=uid,
                              saved_for_later=saved_for_later)
        # Create a list of dictionaries for each row in the query result
        cart_items = [{'name': row[0], 'image': row[1], 'price': row[2], 'quantity': row[3], 
                       'productid': row[4], 'cartid': row[5], 'sellerinventoryid': row[6], 'sellerid': row[7]} for row in rows]
        return cart_items
    
    # a method for entering a new object into the database
    @staticmethod
    def add_cart_item(userid, quantity, saved_for_later, productid):
        try:
            # First, find the sellerinventoryid and sellerid for the given productid
            seller_inventory_row = app.db.execute("""
        SELECT si.id, si.sellerid
        FROM SellerInventories si
        JOIN Products p ON si.productid = p.id
        WHERE p.id = :productid
        """, productid=productid)

            if len(seller_inventory_row) > 1:
                print("No seller inventory found for the given product.")
                return None, False
        
            sellerinventoryid, sellerid = seller_inventory_row[0]

            print('Found sellerinventoryid:', sellerinventoryid, 'for productid:', productid)
                  
            # Check if the cart item already exists
            existing_cart_item = app.db.execute("""
                SELECT id, quantity
                FROM Carts
                WHERE userid = :userid AND sellerinventoryid = :sellerinventoryid AND saved_for_later = :saved_for_later
                """, userid=userid, sellerinventoryid=sellerinventoryid, saved_for_later=saved_for_later)
            print(f'Existing cart item: {existing_cart_item}')

            if len(existing_cart_item) == 1:
                # Update the existing cart item
                cart_id, existing_quantity = existing_cart_item[0]
                new_quantity = existing_quantity + quantity
                app.db.execute("""
                    UPDATE Carts
                    SET quantity = :quantity
                    WHERE id = :id
                    """, quantity=new_quantity, id=cart_id)
                print(f'Updated cart item {cart_id} with new quantity: {new_quantity}')
            else:
                # Insert a new cart item
                new_cart_item = app.db.execute("""
                    INSERT INTO Carts(userid, quantity, sellerinventoryid, saved_for_later)
                    VALUES(:userid, :quantity, :sellerinventoryid, :saved_for_later)
                    RETURNING id
                    """, userid=userid, quantity=quantity, sellerinventoryid=sellerinventoryid, saved_for_later=saved_for_later)
                cart_id = new_cart_item[0]
                print(f'New cart item added with id: {cart_id}')

            return True
        except Exception as e:
            # likely email already in use; better error checking and reporting needed;
            # the following simply prints the error to the console:
            print(str(e))
            return False
        
    @staticmethod
    def move_to_from_saved_for_later(cart_id, in_cart, seller_inventory_id, quantity, userid):
        try:
            # Check if the cart item exists
            existing_item = app.db.execute("""
            SELECT id, quantity, sellerinventoryid
            FROM Carts
            WHERE userid = :userid AND saved_for_later = :in_cart
            """, userid=userid, in_cart=in_cart)
            existing_cart_id, existing_quantity, sellerinventoryid = existing_item[0]
            print(f'Existing cart item found with ID {existing_cart_id} and quantity {existing_quantity}')
            print(f'Adding {quantity} to existing quantity {existing_quantity}')
            ## If the item already exists in the cart, MEANWHILE, they are belong to the same seller, update the quantity
            print(f'Existing sellerinventoryid: {sellerinventoryid}, seller_inventory_id: {seller_inventory_id}')
            print(type(sellerinventoryid), type(seller_inventory_id))
            if sellerinventoryid == int(seller_inventory_id):
                print('Same seller, updating quantity')
                # Existing item found, update the quantity
                new_quantity = existing_quantity + int(quantity)
                print(f'Updating quantity to {new_quantity}')
                app.db.execute("""
                    UPDATE Carts
                    SET quantity = :quantity, saved_for_later = :saved_for_later
                    WHERE id = :cart_id
                    """, quantity=new_quantity, cart_id=existing_cart_id, saved_for_later=in_cart)
            else:
                # the item does not exist in the cart, OR it belongs to anther seller, add it to the cart
                app.db.execute("""
                    UPDATE Carts
                    SET saved_for_later = :saved_for_later
                    WHERE id = :cart_id
                    """, saved_for_later=in_cart, cart_id=cart_id)
            return True
        except Exception as e:
            print(str(e))
            return False

        
    @staticmethod
    def remove_item(userid, cartid):
        try:
            app.db.execute("""
                DELETE FROM Carts
                WHERE userid = :userid AND id = :cartid
                """, userid=userid, cartid=cartid)
            return True
        except Exception as e:
            print(str(e))
            return False

    @staticmethod
    def update_quantity(cart_id, new_quantity):
        print(f'Updating quantity for cart item {cart_id} to {new_quantity}')
        try:
            app.db.execute("""
                UPDATE Carts
                SET quantity = :quantity
                WHERE id = :cart_id
                """, quantity=new_quantity, cart_id=cart_id)
            return True
        except Exception as e:
            print(str(e))
            return False

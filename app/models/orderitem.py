from flask import current_app as app

# For reference, the SQL for the Users table is as follows:
# 
# CREATE TABLE OrderItems (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     orderid INT NOT NULL REFERENCES Orders(id),
#     productid INT NOT NULL REFERENCES Products(id),
#     sellerid INT NOT NULL REFERENCES Users(id),
#     quantity INT NOT NULL,
#     brought_price DECIMAL(12,2) NOT NULL,
#     fulfilled BOOLEAN DEFAULT FALSE
# );

class OrderItem:
    def __init__(self, id, orderid, productid, sellerid, quantity, brought_price, fulfilled):
        self.id = id
        self.orderid = orderid
        self.productid = productid
        self.sellerid = sellerid
        self.quantity = quantity
        self.brought_price = brought_price
        self.fulfilled = fulfilled

    @staticmethod
    def get_user_purchases(user_id):
        # SQL query to retrieve purchase details of a specific user
        query = """
        SELECT 
            P.name AS product_name,
            OI.quantity,
            OI.brought_price,
            O.time_brought AS order_time,
            O.order_status,
            O.id
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        JOIN Products P ON OI.productid = P.id
        WHERE O.userid = :user_id
        ORDER BY O.time_brought DESC;
        """
        rows = app.db.execute(query, user_id=user_id)
        purchase_items = [{'product_name': row[0], 'quantity': row[1], 'brought_price': row[2], 'order_time': row[3], 'order_status':row[4], 'oid':row[5]} for row in rows]
        return purchase_items

    @staticmethod
    def get_filter_options(filter_type, user_id):
        # Determine which type of filter to apply and construct corresponding SQL query
        if filter_type == "item":
            # Query to get distinct product names ordered by a user
            query = """
        SELECT DISTINCT P.name AS product_name
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        JOIN Products P ON OI.productid = P.id
        WHERE O.userid = :user_id
        ORDER BY P.name;
            """
            rows = app.db.execute(query, user_id=user_id)
            return [{'name': row[0]} for row in rows]
        
        elif filter_type == "seller":
            # Query to get distinct seller names who sold items to the user
            query = """
        SELECT DISTINCT U.firstname || ' ' || U.lastname AS seller_name, U.id AS seller_id
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        JOIN Users U ON OI.sellerid = U.id
        WHERE O.userid = :user_id AND U.isSeller = TRUE
        ORDER BY U.firstname || ' ' || U.lastname;
            """
            rows = app.db.execute(query, user_id=user_id)
            return [{'name': row[0], 'id': row[1]} for row in rows]

        elif filter_type == "date":
            # Query to get distinct dates of purchases made by the user, formatted as YYYY-MM-DD
            query = """
        SELECT DISTINCT TO_CHAR(O.time_brought, 'YYYY-MM-DD') AS order_date
        FROM Orders O
        WHERE O.userid = :user_id
        ORDER BY TO_CHAR(O.time_brought, 'YYYY-MM-DD') DESC;
            """
            rows = app.db.execute(query, user_id=user_id)
            return [{'date': row[0]} for row in rows]
        
        else:
            # If filter type does not match any case, return an empty list
            return []
        

    @staticmethod
    def get_filtered_purchases(user_id, filter_type, filter_value):
        # Base query to select purchase details of a user
        query_base = """
            SELECT OI.productid, P.name AS product_name, OI.brought_price, OI.quantity, 
            TO_CHAR(O.time_brought, 'YYYY-MM-DD HH24:MI:SS') AS order_time, O.order_status, O.id
            FROM Orders O
            JOIN OrderItems OI ON O.id = OI.orderid
            JOIN Products P ON OI.productid = P.id
            WHERE O.userid = :user_id
        """
        
        # Add specific filtering conditions based on filter_type
        if filter_type == "item":
            # Filter purchases by product name
            query = query_base + " AND P.name = :filter_value ORDER BY P.name;"
        elif filter_type == "seller":
            # Filter purchases by seller's ID 
            query = """
            SELECT OI.productid, P.name AS product_name, OI.brought_price, OI.quantity,
            TO_CHAR(O.time_brought, 'YYYY-MM-DD HH24:MI:SS') AS order_time, O.order_status, O.id
            FROM Orders O
            JOIN OrderItems OI ON O.id = OI.orderid
            JOIN Products P ON OI.productid = P.id
            JOIN Users U ON OI.sellerid = U.id
            WHERE O.userid = :user_id AND U.id = :filter_value AND U.isSeller = TRUE
        """
        elif filter_type == "date":
            # Filter purchases by the date of purchase
            query = query_base + " AND TO_CHAR(O.time_brought, 'YYYY-MM-DD') = :filter_value ORDER BY O.time_brought DESC;"
        else:
            return []  

        
        rows = app.db.execute(query, user_id=user_id, filter_value=filter_value)
        return [{
            'product_id': row[0],
            'product_name': row[1],
            'brought_price': row[2],
            'quantity': row[3],
            'order_time': row[4],
            'order_status': row[5],
            'oid':row[6]
        } for row in rows]

    @staticmethod
    def get_client_item(user_id):
        query = """
        SELECT 
            P.name AS product_name,
            OI.quantity,
            OI.brought_price,
            O.time_brought AS order_time,
            OI.fulfilled,
            OI.id
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        JOIN Products P ON OI.productid = P.id
        WHERE OI.sellerid = :user_id
        ORDER BY O.time_brought DESC;
        """
        rows = app.db.execute(query, user_id=user_id)
        client_items = [{'product_name': row[0], 'quantity': row[1], 'brought_price': row[2], 'order_time': row[3], 'order_status':row[4], 'orderitem_id':row[5]} for row in rows]
        return client_items


    @staticmethod
    def get_buyerid_by_itemid(item_id):
        query = """
        SELECT 
            O.userid
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        WHERE OI.id = :item_id;
        """
        rows = app.db.execute(query, item_id=item_id)
        if rows:
            return rows[0][0]
        else:
            return None
    

    @staticmethod
    def fulfill_orderitem(item_id):
        query = """
        UPDATE OrderItems
        SET fulfilled = true
        WHERE id = :item_id;
        """
        rows = app.db.execute(query, item_id=item_id)
        

    @staticmethod
    def get_order_id(item_id):
        query = """
        SELECT 
            OI.orderid
        FROM OrderItems OI
        WHERE OI.id = :item_id;
        """
        rows = app.db.execute(query, item_id=item_id)
        if rows:
            return rows[0][0]
        else:
            return None


    @staticmethod
    def get_in_process_num(oid):
        query = """
        SELECT 
            count(*)
        FROM OrderItems
        WHERE orderid = :oid
        AND fulfilled = false;
        """
        rows = app.db.execute(query, oid=oid)
        if rows:
            return rows[0][0]
        else:
            return None
        
    @staticmethod
    def create_order_item(orderid, productid, sellerid, quantity, brought_price):
        query = """
        INSERT INTO OrderItems (orderid, productid, sellerid, quantity, brought_price)
        VALUES (:orderid, :productid, :sellerid, :quantity, :brought_price)
        RETURNING id;
        """
        rows = app.db.execute(query, orderid=orderid, productid=productid, sellerid=sellerid, quantity=quantity, brought_price=brought_price)
        return rows[0][0]


    @staticmethod
    def get_order_items_by_order_id(order_id):
        query = """
        SELECT 
            OI.id,
            P.name AS product_name,
            OI.quantity,
            OI.brought_price,
            OI.fulfilled,
            P.image AS product_image
        FROM OrderItems OI
        JOIN Products P ON OI.productid = P.id
        WHERE OI.orderid = :order_id;
        """
        rows = app.db.execute(query, order_id=order_id)
        order_items = [{'id': row[0], 'product_name': row[1], 
                        'quantity': row[2], 
                        'brought_price': row[3], 
                        'fulfilled': row[4], 
                        'product_image': row[5]} for row in rows]
        return order_items


    def get_purchases_by_category(user_id):
        query = """
        SELECT C.name AS category_name, SUM(OI.quantity) AS total_quantity, SUM(OI.brought_price * OI.quantity) AS total_amount
        FROM Orders O
        JOIN OrderItems OI ON O.id = OI.orderid
        JOIN Products P ON OI.productid = P.id
        JOIN Categories C ON P.categoryid = C.id
        WHERE O.userid = :user_id
        GROUP BY C.name
        """
        rows = app.db.execute(query, user_id=user_id)
        return [{
        'category_name': row[0],
        'total_quantity': row[1],
        'total_amount': row[2]
        } for row in rows]

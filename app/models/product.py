from flask import current_app as app

# For reference, the SQL for the Users table is as follows:
# 
# CREATE TABLE Products (
#     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
#     categoryid INT NOT NULL REFERENCES Categories(id),
#     name VARCHAR(255) UNIQUE NOT NULL,
#     description VARCHAR(511),
#     image VARCHAR(255),
# );

class Product:
    def __init__(self, id, categoryid, name, description, image, price = None, rating = None):
        self.id = id
        self.categoryid = categoryid
        self.name = name
        self.description = description
        self.image = image
        self.price = price
        self.rating = rating

    @staticmethod
    def get(id):
        rows = app.db.execute('''
            SELECT id, name, price, available
            FROM Products
            WHERE id = :id
            ''',
                              id=id)
        return Product(*(rows[0])) if rows is not None else None


    @staticmethod
    def get_all():
        rows = app.db.execute('''
            SELECT *
            FROM Products
            ''',)
        return [Product(*row) for row in rows]
    

    @staticmethod
    def get_product_number():
        row = app.db.execute('''
            SELECT COUNT(*)
            FROM Products
            ''',)
        return row[0][0]
    

    @staticmethod
    def get_expensive_products_paged(page, limit):
        offset = (page - 1) * limit
        rows = app.db.execute('''
            SELECT p.id, p.categoryid, p.name, p.description, p.image, ph.price, COALESCE(ROUND(avg_rating.avg_rate, 2), 0)
            FROM Products p
            JOIN SellerInventories si ON p.id = si.productid
            JOIN PriceHistory ph ON si.id = ph.inventoryid
            JOIN (
                SELECT inventoryid, MAX(time_changed) AS latest_time
                FROM PriceHistory
                GROUP BY inventoryid
            ) ph_latest ON ph.inventoryid = ph_latest.inventoryid AND ph.time_changed = ph_latest.latest_time
            LEFT JOIN (
                SELECT productid, AVG(rate) AS avg_rate
                FROM ProductComments
                GROUP BY productid
            ) avg_rating ON p.id = avg_rating.productid
            ORDER BY ph.price DESC
            LIMIT :limit OFFSET :offset
            ''',
                            limit=limit, offset=offset)
        return [Product(*row) for row in rows]

    

    @staticmethod
    def search_products_by_name(search, category_id=None, min_rating=None, min_price=None, max_price=None):
        query_params = {
            'search': search,
            'min_price': min_price,
            'max_price': max_price
        }
        conditions = []

        if category_id:
            conditions.append('p.categoryid = :category_id')
            query_params['category_id'] = category_id

        if min_rating is not None:
            conditions.append('COALESCE(avg_rating.avg_rate, 0) >= :min_rating')
            query_params['min_rating'] = min_rating

        condition_string = ' AND '.join(conditions)
        if condition_string:
            condition_string = 'AND ' + condition_string

        query = f'''
            SELECT p.id, p.categoryid, p.name, p.description, p.image, MIN(ph.price) AS min_price, COALESCE(ROUND(avg_rating.avg_rate, 2), 0) AS average_rating
            FROM Products p
            JOIN SellerInventories si ON p.id = si.productid
            JOIN PriceHistory ph ON si.id = ph.inventoryid
            JOIN (
                SELECT inventoryid, MAX(time_changed) AS latest_time
                FROM PriceHistory
                GROUP BY inventoryid
            ) ph_latest ON ph.inventoryid = ph_latest.inventoryid AND ph.time_changed = ph_latest.latest_time
            LEFT JOIN (
                SELECT productid, AVG(rate) AS avg_rate
                FROM ProductComments
                GROUP BY productid
            ) avg_rating ON p.id = avg_rating.productid
            WHERE p.name ILIKE '%' || :search || '%' {condition_string}
            GROUP BY p.id, p.categoryid, p.name, p.description, p.image, avg_rating.avg_rate
            HAVING (MIN(ph.price) >= :min_price OR :min_price IS NULL) AND (MIN(ph.price) <= :max_price OR :max_price IS NULL)
            ORDER BY min_price ASC
            '''
        rows = app.db.execute(query, **query_params)
        return [Product(*row) for row in rows]

        
    @staticmethod
    def search_products_by_description(search, category_id=None, min_rating=None, min_price=None, max_price=None):
        query_params = {
            'search': search,
            'min_price': min_price,
            'max_price': max_price
        }
        conditions = []

        if category_id:
            conditions.append('p.categoryid = :category_id')
            query_params['category_id'] = category_id

        if min_rating is not None:
            conditions.append('COALESCE(avg_rating.avg_rate, 0) >= :min_rating')
            query_params['min_rating'] = min_rating

        condition_string = ' AND '.join(conditions)
        if condition_string:
            condition_string = 'AND ' + condition_string

        query = f'''
            SELECT p.id, p.categoryid, p.name, p.description, p.image, MIN(ph.price) AS min_price, COALESCE(ROUND(avg_rating.avg_rate, 2), 0) AS average_rating
            FROM Products p
            JOIN SellerInventories si ON p.id = si.productid
            JOIN PriceHistory ph ON si.id = ph.inventoryid
            JOIN (
                SELECT inventoryid, MAX(time_changed) AS latest_time
                FROM PriceHistory
                GROUP BY inventoryid
            ) ph_latest ON ph.inventoryid = ph_latest.inventoryid AND ph.time_changed = ph_latest.latest_time
            LEFT JOIN (
                SELECT productid, AVG(rate) AS avg_rate
                FROM ProductComments
                GROUP BY productid
            ) avg_rating ON p.id = avg_rating.productid
            WHERE p.description ILIKE '%' || :search || '%' {condition_string}
            GROUP BY p.id, p.categoryid, p.name, p.description, p.image, avg_rating.avg_rate
            HAVING (MIN(ph.price) >= :min_price OR :min_price IS NULL) AND (MIN(ph.price) <= :max_price OR :max_price IS NULL)
            ORDER BY min_price ASC
            '''
        rows = app.db.execute(query, **query_params)
        return [Product(*row) for row in rows]


    @staticmethod
    def get_product_by_id(product_id):
        rows = app.db.execute('''
            SELECT p.id, p.categoryid, p.name, p.description, p.image, ph.price, COALESCE(ROUND(avg_rating.avg_rate, 2), 0) AS average_rating
            FROM Products p
            JOIN SellerInventories si ON p.id = si.productid
            JOIN PriceHistory ph ON si.id = ph.inventoryid
            JOIN (
                SELECT inventoryid, MAX(time_changed) AS latest_time
                FROM PriceHistory
                GROUP BY inventoryid
            ) ph_latest ON ph.inventoryid = ph_latest.inventoryid AND ph.time_changed = ph_latest.latest_time
            LEFT JOIN (
                SELECT productid, AVG(rate) AS avg_rate
                FROM ProductComments
                GROUP BY productid
            ) avg_rating ON p.id = avg_rating.productid
            WHERE p.id = :product_id
            ''',
                            product_id=product_id)
        if rows:
            row = rows[0]
            return Product(*row)
        else:
            return None
    @staticmethod
    def get_reviews(product_id):
        reviews = app.db.execute('''
            SELECT pc.id, pc.comment, pc.time_commented, pc.rate, u.firstname, u.lastname, u.id
            FROM ProductComments pc
            JOIN Users u ON pc.userid = u.id
            WHERE pc.productid = :product_id
            ORDER BY pc.time_commented DESC
            ''',
                                product_id=product_id)

        return reviews if reviews is not None else None


    @staticmethod
    def get_sellers(product_id):
        sellers = app.db.execute('''
            SELECT u.id, u.firstname, u.lastname, u.email, si.quantity, ph.price AS current_price, si.id AS inventory_id
            FROM Users u
            JOIN SellerInventories si ON u.id = si.sellerid
            JOIN (
                SELECT ph.inventoryid, ph.price
                FROM PriceHistory ph
                JOIN (
                    SELECT ph2.inventoryid, MAX(ph2.time_changed) AS latest_time
                    FROM PriceHistory ph2
                    GROUP BY ph2.inventoryid
                ) latest_prices ON ph.inventoryid = latest_prices.inventoryid
                                AND ph.time_changed = latest_prices.latest_time
            ) ph ON si.id = ph.inventoryid
            WHERE si.productid = :product_id
            ''',
            product_id=product_id)
        return sellers if sellers is not None else None


        
    @staticmethod
    def get_all_categories():
        rows = app.db.execute('''
            SELECT id, name
            FROM Categories
            ORDER BY name ASC
        ''')
        return rows  



    @staticmethod
    def get_topfive_products():
        rows = app.db.execute('''
            SELECT description, image, name, id
            FROM Products
            WHERE id IN (
                SELECT P.id
                FROM Products P
                JOIN Orderitems O ON P.id = O.productid
                GROUP BY P.id
                ORDER BY COUNT(quantity) DESC
                LIMIT 5
            )
        ''')
        if rows:
            return rows
        else:
            return None
